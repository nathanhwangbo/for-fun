---
title: "prime factorization"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message = F}
library(tidyverse)
library(tidymodels)
library(poissonreg)
library(RColorBrewer)
```

there's a picture puzzle mapping numbers 1-100 to different color combinations. spoiler alert ----- the color scheme for each number represents its prime factorization (so each prime has a unique color). 

q: can we learn this pattern?

i'll try building models that take in the color scheme and output a number. to keep things easy and in line with the picture, i'll only use numbers generated by the 25 prime numbers between 1-100, and only using numbers with at most 6 prime factors (because 2^6 < 100 and 2^7 > 100). in summary, the labels in our regression model will be products of at most 6 primes, where each of the primes is less than 100.

we'll structure the data by turning each number into a row with 7 columns (1 for the number, and 6 for the color of each column)

of course, colors are 1:1 with primes, and the label is just the product of the primes, so we expect that a large enough model could learn this deterministic relationship, mostly, this is just a way for me to play around with some of the new dplyr 1.0.0 changes and the new tidymodels interface :)


#### helper functions
```{r}
#' check if number if prime
#' idea: brute force check if there's a remainder with any number < sqrt 
#'       (only need to go up to sqrt because 2 is not a factor)
#' @param num is a positive integer (i didn't add error handling hehe)
#' @return logical
is_prime <- function(num){
  if(num == 1){
    return(FALSE)
  } else if(num < 4){
    return(TRUE)
  } else{
    # go through integers up to the square root and check if there's a remainder
    # .. this probably breaks for huge numbers
    for(i in 2:floor(sqrt(num))){
      if(num %% i == 0){
        return(FALSE)
      }
    }
  }
  return(TRUE)
}

#' get prime factors of a number
#' idea: brute force our way through all the prime numbers < num and see if any of them are a factor
#'       if it's a factor, then divide and start again. keep going until you get the prime factorization
#' @param num is a natural number (no error handling xd)
#' @return a numeric vector of prime factors
prime_fcts <- function(num){
  prime_factors <- numeric()
  all_primes <- which(purrr::map_lgl(1:floor(num), ~is_prime(.x)))
  
  if(num == 1){
    return(NULL)
  }
  while(TRUE){
    if(is_prime(num)){
      prime_factors <- c(prime_factors, num)
      return(prime_factors)
    }
    for(prime in all_primes){
      if(num %% prime == 0){
        prime_factors <- c(prime_factors, prime)
        num <- num / prime
        break
      }
    }
  
  }
}


#' try to create the figure in the puzzle
#' @param data is a long dataframe with columns `number` and `factors`
#' @param num is a number/vector of numbers, which you want prime factor plots for
plot_number <- function(data, num){
  plot_data <- data %>%
    filter(number %in% num) %>%
    group_by(number) %>%
    mutate(width = n(),
           height = 4,
           factors = fct_drop(fct_rev(factors))
           ) %>%
    ungroup()
    

  ggplot(plot_data) +
    geom_col(aes(height, width, fill = factors), color = 'black') + 
    coord_flip() +
    labs(x = '',
         y = '') + 
    theme_bw() + 
    facet_wrap(~number, scales = 'free_x') + 
    theme(axis.text = element_blank(), 
          axis.ticks = element_blank(),
          legend.position = 'none'
          )
}

```

#### generate the data in the picture

idea: struture the data by having one number per row, and each column being a color in the picture going left to right. eg the last row will be (100, 2, 2, 5, 5, 1, 1). 1, 2 and 5 are all treated as factors, and 1 is the factor level for "no color", because 100 has only 4 prime factors. just like in the picture, prime factors are sorted going small -> large from left -> right


```{r, message = F}
set.seed(20200901)
#each prime gets its own color
primes_sub_100 <- which(purrr::map_lgl(1:100, ~is_prime(.x)))
my_colors = sample(colors(), size = length(primes_sub_100))

color_map <- bind_cols(prime_fct = primes_sub_100, color = my_colors)

prime_factorizations <- purrr::map(1:100, ~prime_fcts(.x))
max_num_cols <- max(purrr::map_dbl(prime_factorizations, ~length(.x)))



picture_data_wide <- tibble(
  number = 1:100,
  factorization = prime_factorizations
  ) %>%
  unnest_wider(col = factorization) %>%
  rename_with(~str_replace_all(.x, "\\.{3}", "fct")) %>%
  mutate(
    across(everything(), ~ifelse(is.na(.x), 1, .x)), # 1 represents no color
    across(starts_with('fct'), ~as_factor(.x))
    ) 

picture_data_long <- tibble(
  number = 1:100,
  factorization = prime_factorizations
  ) %>%
  unnest_longer(factorization, values_to = 'factors') %>%
  filter(number != 1) %>%
  mutate(factors = as_factor(factors))



# ggplot(picture_data_long) +
#   geom_histogram(aes(factors)) + 
#   labs(title = 'number of prime occurances in 1:100')
```

#### let's try to recreate the plot
```{r, fig.height = 10}
plot_number(picture_data_long, 1:100)
```



#### now generate new test data to see how well the scheme is learned
note we use sample colors column by column (eg 97 can't show up anywhere other than the first column)
so we can't separate color from its position
```{r}
set.seed(20200901)
test_data <- purrr::map_dfc(picture_data_wide, 
                            ~sample(unique(.x), size = 100, replace = T)
) %>%
  select(-number) %>%
  #rename_with(~str_replace(.x, '\\.{3}', 'fct')) %>%
  #mutate(across(everything(), ~as_factor(.x))) %>%
  # remove any 'test' data
  anti_join(picture_data_wide) %>%
  # tricky fct -> numeric conversion
  mutate(across(starts_with('fct'), ~as.numeric(levels(.x))[.x])) %>% 
  rowwise() %>%
  mutate(truth = prod(c_across(everything()))) %>%
  ungroup() %>%
  # conversion back to fct
  mutate(across(starts_with('fct'), ~as_factor(.x)))


# for plotting purposes
test_data_long <- test_data %>%
  pivot_longer(cols = starts_with('fct'),
               values_to = 'factors'
               ) %>%
  select('number' = truth, factors) %>%
  filter(factors != 1)
```


#### fit on 1:100 and see how well it learned the scheme
```{r}
glm_fit <- poisson_reg() %>%
  set_engine('glm') %>%
  fit(number ~ ., data = picture_data_wide)


glm_pred <- predict(glm_fit, new_data = test_data)

test_data %>%
  cbind(glm_pred) %>%
  #mutate(rmse = yardstick::rmse_vec(truth, .pred)) %>%
  ggplot(aes(truth, .pred)) +
  geom_point() + 
  geom_abline(slope = 1, intercept = 0) + 
  labs(title = 'practically perfect prediction', 
       x = 'truth', 
       y = 'prediction')
```


#### plot the new values

```{r, fig.height = 10}
plot_number(test_data_long, unique(test_data_long$number))
```




